# schema

Stately schema types and utilities.

This module provides the main schema types for Stately applications.
It re-exports types from `@statelyjs/schema` and adds the core plugin
types automatically.

## Key Types

- **`DefineConfig`** - Define your application's schema configuration
- **`Schemas`** - The schema type used throughout your app
- **`stately`** - Factory function to create a schema runtime

## Example

```typescript
import { stately, type DefineConfig, type Schemas } from '@statelyjs/stately/schema';
import type { components, paths, operations } from './generated/types';
import { PARSED_SCHEMAS } from './generated/schemas';

// Define your schema configuration
type MyConfig = DefineConfig<components, paths, operations>;

// Create the schemas type for your app
type MySchemas = Schemas<MyConfig>;

// Create the runtime
const schema = stately<MySchemas>(openapiDoc, PARSED_SCHEMAS);
```

## Interfaces

### BaseNode

Defined in: packages/schema/dist/nodes.d.ts:26

Base interface for all schema nodes.

Every node in the schema system extends this interface. The `nodeType` discriminator
enables TypeScript's discriminated union narrowing for type-safe node handling.

Codegen emits `nodeType: 'unknown'` for schemas it cannot parse, allowing graceful
degradation - the UI will render a fallback for these.

#### Remarks

No index signature is used - this allows TypeScript's discriminated union narrowing
to work correctly. All node properties must be explicitly defined in their respective
node type interfaces.

#### Properties

##### description?

> `optional` **description**: `string`

Defined in: packages/schema/dist/nodes.d.ts:30

Optional description from the OpenAPI schema.

##### nodeType

> **nodeType**: `string`

Defined in: packages/schema/dist/nodes.d.ts:28

Discriminator identifying the node type (e.g., 'object', 'string', 'array').

## Type Aliases

### AnyPaths

> **AnyPaths** = `object`

Defined in: packages/schema/dist/api.d.ts:9

Base type for OpenAPI paths - accepts any object structure.

***

### AnyRecord

> **AnyRecord** = `Record`\<`string`, `unknown`\>

Defined in: packages/schema/dist/helpers.d.ts:8

A record with string keys and unknown values.

***

### AnySchemaAugments

> **AnySchemaAugments** = readonly [`AnySchemaPlugin`](#anyschemaplugin)[]

Defined in: packages/schema/dist/plugin.d.ts:91

***

### AnySchemaPlugin

> **AnySchemaPlugin** = [`PluginAugment`](../schema/plugin.md#pluginaugment)\<`string`, [`NodeMap`](#nodemap), `any`, `any`, `any`\>

Defined in: packages/schema/dist/plugin.d.ts:90

***

### DefineComponents

> **DefineComponents**\<`T`\> = `T`

Defined in: packages/schema/dist/generated.d.ts:68

Define the components structure your plugin expects.
Typically generated by openapi-typescript with a schemas property.

#### Type Parameters

##### T

`T` *extends* `object` = \{ `schemas?`: `Record`\<`string`, `any`\>; \}

#### Example

```typescript
type MyComponents = DefineComponents<{
  schemas: {
    MyEntity: { id: string; name: string };
    MyOtherType: { value: number };
  }
}>;
```

***

### DefineComponentSchemas

> **DefineComponentSchemas**\<`T`\> = `T`

Defined in: packages/schema/dist/generated.d.ts:85

Define the component schemas structure your plugin expects.
Use this when you only care about schemas, not the full components object.

#### Type Parameters

##### T

`T` *extends* `Record`\<`string`, `any`\> = `Record`\<`string`, `any`\>

#### Example

```typescript
type MyComponentsSchemas = DefineComponentSchemas<{
  MyEntity: { id: string; name: string };
  MyOtherType: { value: number };
}>;
```

***

### DefineConfig

> **DefineConfig**\<`C`, `P`, `O`, `N`\> = `DefineCoreConfig`\<`C`, `P`, [`DefineOperations`](#defineoperations)\<`O`\>, `N`\>

Defined in: [packages/stately/src/schema.ts:69](https://github.com/GeorgeLeePatterson/stately/blob/b8910accb3b200676731aeb7f39e1bb8d666404d/packages/stately/src/schema.ts#L69)

Define your application's Stately configuration.

This type helper combines your OpenAPI-generated types with Stately's
core plugin to create a complete configuration type. Use this when
defining your `Schemas` type.

The core plugin is automatically included, providing:
- Entity CRUD operations
- Standard node types (primitives, objects, arrays, etc.)
- Link resolution utilities

#### Type Parameters

##### C

`C` *extends* [`DefineComponents`](#definecomponents) = [`DefineComponents`](#definecomponents)

Components type from OpenAPI codegen (e.g., `components`)

##### P

`P` *extends* [`DefinePaths`](#definepaths) = [`DefinePaths`](#definepaths)

Paths type from OpenAPI codegen (e.g., `paths`)

##### O

`O` *extends* `object` = `object`

Operations type from OpenAPI codegen (e.g., `operations`)

##### N

`N` *extends* [`DefineGeneratedNodes`](#definegeneratednodes)\<[`NodeMap`](#nodemap)\> = [`DefineGeneratedNodes`](#definegeneratednodes)\<[`NodeMap`](#nodemap)\>

Generated node map from Stately codegen (usually inferred)

#### Example

```typescript
import type { components, paths, operations } from './generated/types';

type MyConfig = DefineConfig<components, paths, operations>;
type MySchemas = Schemas<MyConfig>;
```

***

### DefineData

> **DefineData**\<`T`\> = `T`

Defined in: packages/schema/dist/plugin.d.ts:60

Define runtime data to expose from your plugin.

#### Type Parameters

##### T

`T` *extends* [`AnyRecord`](#anyrecord) = [`AnyRecord`](#anyrecord)

#### Example

```typescript
type MyData = DefineData<{
  registry: Map<string, string>;
  cache: Record<string, unknown>;
}>;
```

***

### DefineGeneratedNodes

> **DefineGeneratedNodes**\<`T`\> = `T`

Defined in: packages/schema/dist/generated.d.ts:112

Define the generated node structure your plugin expects.
All nodes must extend BaseNode.

#### Type Parameters

##### T

`T` *extends* [`NodeMap`](#nodemap) = [`NodeMap`](#nodemap)

#### Example

```typescript
type MyGeneratedNodes = DefineGeneratedNodes<{
  User: ObjectNode;
  Post: ObjectNode;
}>;
```

***

### DefineNodeMap

> **DefineNodeMap**\<`T`\> = `{ [K in keyof T]: T[K] }` & `object`

Defined in: packages/schema/dist/plugin.d.ts:32

Define the node map for your plugin augment.
The type system will automatically add the required index signature.

#### Type Declaration

##### unknown

> **unknown**: [`UnknownNode`](../schema/nodes.md#unknownnode)

#### Type Parameters

##### T

`T` *extends* [`NodeMap`](#nodemap) = [`NodeMap`](#nodemap)

#### Example

```typescript
type MyNodeMap = DefineNodeMap<{
  myCustomNode: MyCustomNodeType;
  anotherNode: AnotherNodeType;
}>;
```

***

### DefineOperations

> **DefineOperations**\<`T`\> = `{ [K in keyof T]: OperationEntry }`

Defined in: packages/schema/dist/api.d.ts:31

Define the operations structure for type-safe API bindings.
Transforms an operations interface (from openapi-typescript) into a mapped type
with proper index signature for TypeScript compatibility.

#### Type Parameters

##### T

`T` *extends* `object` = [`OperationMap`](../schema/api.md#operationmap)

The operations interface from openapi-typescript

***

### DefinePaths

> **DefinePaths**\<`T`\> = `T`

Defined in: packages/schema/dist/generated.d.ts:99

Define the paths structure your plugin expects.
Typically generated by openapi-typescript as a record of path strings to operations.

#### Type Parameters

##### T

`T` *extends* `Record`\<`string`, `any`\> = [`AnyPaths`](#anypaths)

#### Example

```typescript
type MyPaths = DefinePaths<{
  '/api/users': {
    get: { responses: { 200: { content: { 'application/json': User[] } } } };
  };
}>;
```

***

### DefinePlugin

> **DefinePlugin**\<`Name`, `Nodes`, `Types`, `Data`, `Utils`\> = [`PluginAugment`](../schema/plugin.md#pluginaugment)\<[`RequireLiteral`](../schema/helpers.md#requireliteral)\<`Name`, `"Plugin names must be string literals"`\>, `Nodes`, `Types`, `Data`, `Utils`\>

Defined in: packages/schema/dist/index.d.ts:63

Public helper for declaring a plugin augment.

Schema augment contributed by a plugin. Each augment registers the canonical
node map it provides plus any additional helper types it wants to merge into
the final `Schemas` surface. Plugin authors only need to supply the node map;
everything else will be wired into the `Plugin` view automatically.

Enforces string-literal names so downstream utilities preserve keyed utils, types, and data.
Plugin authors should export their augments defined with this type

#### Type Parameters

##### Name

`Name` *extends* `string`

##### Nodes

`Nodes` *extends* [`NodeMap`](#nodemap) = [`NodeMap`](#nodemap)

##### Types

`Types` *extends* [`DefineTypes`](#definetypes) = [`NeverRecord`](#neverrecord)

##### Data

`Data` *extends* [`DefineData`](#definedata) = [`NeverRecord`](#neverrecord)

##### Utils

`Utils` *extends* [`DefineUtils`](#defineutils)\<[`AnyRecord`](#anyrecord)\> = [`EmptyRecord`](#emptyrecord)

***

### DefineTypes

> **DefineTypes**\<`T`\> = `T`

Defined in: packages/schema/dist/plugin.d.ts:48

Define additional types to expose from your plugin.

#### Type Parameters

##### T

`T` *extends* [`AnyRecord`](#anyrecord) = [`NeverRecord`](#neverrecord)

#### Example

```typescript
type MyTypes = DefineTypes<{
  MyHelper: { foo: string };
  MyConfig: { bar: number };
}>;
```

***

### DefineUtils

> **DefineUtils**\<`T`\> = `T` & `object`

Defined in: packages/schema/dist/plugin.d.ts:72

Define utility functions to expose from your plugin.

#### Type Declaration

##### validate?

> `optional` **validate**: [`ValidateHook`](../schema/validation.md#validatehook)

#### Type Parameters

##### T

`T` *extends* [`AnyRecord`](#anyrecord) = [`EmptyRecord`](#emptyrecord)

#### Example

```typescript
type MyUtils = DefineUtils<{
  parseFile: (path: string) => FileNode;
  validateFile: (file: FileNode) => boolean;
}>;
```

***

### EmptyRecord

> **EmptyRecord** = `Record`\<`string`, `never`\>

Defined in: packages/schema/dist/helpers.d.ts:12

A record that exists but has no properties.

***

### GeneratedNodeMap

> **GeneratedNodeMap**\<`Config`\> = `Config`\[`"nodes"`\] *extends* `Record`\<`string`, `any`\> ? `{ [K in StringKeys<Config["nodes"]>]: Config["nodes"][K] extends BaseNode ? Config["nodes"][K] : never }` : [`NodeMap`](#nodemap)

Defined in: packages/schema/dist/generated.d.ts:113

#### Type Parameters

##### Config

`Config` *extends* `StatelyConfig`

***

### NeverRecord

> **NeverRecord** = `Record`\<`never`, `never`\>

Defined in: packages/schema/dist/helpers.d.ts:10

An empty record with no valid keys. Used for "no data" scenarios.

***

### NodeInformation

> **NodeInformation**\<`Nodes`\> = `object`

Defined in: packages/schema/dist/nodes.d.ts:61

Derived type information from a node map.
Provides convenient access to node types, unions, and discriminators.

#### Type Parameters

##### Nodes

`Nodes`

The node map to derive information from

#### Properties

##### AnyNode

> **AnyNode**: [`NodeValuesWithUnknown`](../schema/nodes.md#nodevalueswithunknown)\<`Nodes`\>

Defined in: packages/schema/dist/nodes.d.ts:67

Union of all node types (for discriminated union patterns).

##### NodeNames

> **NodeNames**: [`LiteralKeys`](../schema/helpers.md#literalkeys)\<`Nodes` & `object`\>

Defined in: packages/schema/dist/nodes.d.ts:69

Union of all node name strings.

##### Nodes

> **Nodes**: `Nodes` & `object`

Defined in: packages/schema/dist/nodes.d.ts:63

The node map with UnknownNode included.

###### Type Declaration

###### unknown

> **unknown**: [`UnknownNode`](../schema/nodes.md#unknownnode)

##### NodeTypes

> **NodeTypes**: [`NodeValuesWithUnknown`](../schema/nodes.md#nodevalueswithunknown)\<`Nodes`\> *extends* `object` ? `Extract`\<`T`, `string`\> : `string`

Defined in: packages/schema/dist/nodes.d.ts:73

Union of all nodeType discriminator values.

***

### NodeMap

> **NodeMap** = `Record`\<`string`, [`BaseNode`](#basenode)\>

Defined in: packages/schema/dist/nodes.d.ts:41

A map of node names to their node definitions.

***

### OperationBindings

> **OperationBindings**\<`Paths`, `Operations`\> = `Record`\<keyof `Operations`, \{ `method`: `HttpMethod`; `path`: `Extract`\<keyof `Paths`, `string`\>; \}\>

Defined in: packages/schema/dist/api.d.ts:47

Maps operation names to their HTTP method and path.
Used by plugins to define how friendly operation names map to OpenAPI paths.

#### Type Parameters

##### Paths

`Paths`

The paths interface from openapi-typescript

##### Operations

`Operations` *extends* [`OperationMap`](../schema/api.md#operationmap)

The operations interface from openapi-typescript

#### Example

```typescript
type MyBindings = OperationBindings<paths, operations>;
// { list_users: { method: 'get', path: '/users' }, ... }
```

***

### PluginFactory()

> **PluginFactory**\<`S`\> = (`runtime`) => [`Stately`](../schema/stately.md#stately)\<`S`\>

Defined in: packages/schema/dist/stately.d.ts:74

Factory function for creating schema plugins.

A plugin factory receives the current runtime and returns an augmented runtime.
Plugins can add data to `runtime.data`, utilities to `runtime.plugins`, and
validation hooks.

#### Type Parameters

##### S

`S` *extends* [`StatelySchemas`](../schema/schema.md#statelyschemas)\<`any`, `any`\>

The application's schema type

#### Parameters

##### runtime

[`Stately`](../schema/stately.md#stately)\<`S`\>

#### Returns

[`Stately`](../schema/stately.md#stately)\<`S`\>

#### Example

```typescript
const myPlugin: PluginFactory<MySchemas> = (runtime) => ({
  ...runtime,
  data: { ...runtime.data, myData: computeMyData(runtime) },
  plugins: { ...runtime.plugins, myPlugin: { utils: myUtils } },
});
```

***

### PluginNodeUnion

> **PluginNodeUnion**\<`S`\> = `S`\[`"plugin"`\]\[`"AnyNode"`\]

Defined in: packages/schema/dist/plugin.d.ts:19

Plugin helper types for nodes

#### Type Parameters

##### S

`S` *extends* [`StatelySchemas`](../schema/schema.md#statelyschemas)\<`any`, `any`\>

***

### Schemas

> **Schemas**\<`Config`, `Augments`\> = [`StatelySchemas`](../schema/schema.md#statelyschemas)\<`Config`, readonly \[`CorePlugin`\<`Config`, `Augments`\>, `...Augments`\]\>

Defined in: [packages/stately/src/core/schema/index.ts:60](https://github.com/GeorgeLeePatterson/stately/blob/b8910accb3b200676731aeb7f39e1bb8d666404d/packages/stately/src/core/schema/index.ts#L60)

Stately plugin types integration for schemas - Main API

Variance annotation enforces that Config can only be used covariantly.
This acts as a compile-time guardrail preventing invariant-causing patterns
like `keyof Config['nodes']` from being introduced anywhere in the type system.

#### Type Parameters

##### Config

`Config` *extends* `CoreStatelyConfig` = `CoreStatelyConfig`

##### Augments

`Augments` *extends* [`AnySchemaAugments`](#anyschemaaugments) = \[\]

***

### Stately

> **Stately**\<`S`\> = [`Stately`](../schema/stately.md#stately)\<`S`\>

Defined in: [packages/stately/src/core/schema/index.ts:50](https://github.com/GeorgeLeePatterson/stately/blob/b8910accb3b200676731aeb7f39e1bb8d666404d/packages/stately/src/core/schema/index.ts#L50)

#### Type Parameters

##### S

`S` *extends* [`Schemas`](#schemas)\<`any`, `any`\> = [`Schemas`](#schemas)

***

### StatelyBuilder

> **StatelyBuilder**\<`S`\> = [`StatelyBuilder`](../schema/stately.md#statelybuilder)\<`S`\>

Defined in: [packages/stately/src/core/schema/index.ts:51](https://github.com/GeorgeLeePatterson/stately/blob/b8910accb3b200676731aeb7f39e1bb8d666404d/packages/stately/src/core/schema/index.ts#L51)

#### Type Parameters

##### S

`S` *extends* [`Schemas`](#schemas)\<`any`, `any`\> = [`Schemas`](#schemas)

## Variables

### CORE\_PLUGIN\_NAME

> `const` **CORE\_PLUGIN\_NAME**: `"core"`

Defined in: [packages/stately/src/core/schema/plugin.ts:17](https://github.com/GeorgeLeePatterson/stately/blob/b8910accb3b200676731aeb7f39e1bb8d666404d/packages/stately/src/core/schema/plugin.ts#L17)

***

### createOperationBindingsFactory()

> `const` **createOperationBindingsFactory**: \<`Paths`, `Ops`\>() => \<`T`\>(`ops`) => `T`

Defined in: packages/schema/dist/api.d.ts:67

Creates a type-safe factory for defining operation bindings.
The factory validates that each operation's method and path are valid for the given OpenAPI spec.

#### Type Parameters

##### Paths

`Paths` *extends* `object`

The paths interface from openapi-typescript

##### Ops

`Ops` *extends* [`OperationMap`](../schema/api.md#operationmap)

The operations interface from openapi-typescript

#### Returns

A factory function that validates and returns the operation bindings

> \<`T`\>(`ops`): `T`

##### Type Parameters

###### T

`T` *extends* `Record`\<keyof `Ops`, \{ `method`: `HttpMethod`; `path`: `any`; \}\>

##### Parameters

###### ops

`T` & `{ [K in keyof T]: T[K] extends { method: infer M; path: infer P } ? M extends HttpMethod ? P extends PathsWithMethod<Paths, M> ? { method: M; path: P } : never : never : never }`

##### Returns

`T`

#### Example

```typescript
const bindings = createOperationBindingsFactory<paths, operations>()({
  list_users: { method: 'get', path: '/users' },
  create_user: { method: 'post', path: '/users' },
});
```

## Functions

### stately()

> **stately**\<`S`\>(`openapi`, `nodes`): [`StatelyBuilder`](../schema/stately.md#statelybuilder)\<`S`\>

Defined in: [packages/stately/src/core/schema/index.ts:75](https://github.com/GeorgeLeePatterson/stately/blob/b8910accb3b200676731aeb7f39e1bb8d666404d/packages/stately/src/core/schema/index.ts#L75)

Stately plugin functionality integration - Main API

Convenience helper that seeds the runtime with the core schema plugin so consumers get all core
helpers/validators out of the box. Additional schema plugins can be appended by chaining
`.withPlugin(...)` on the returned builder.

#### Type Parameters

##### S

`S` *extends* [`Schemas`](#schemas)\<`any`, `any`\> = [`Schemas`](#schemas)\<`CoreStatelyConfig`\<`CoreComponentInput`, `CorePathsInput`, `any`, [`NodeMap`](#nodemap)\>, \[\]\>

#### Parameters

##### openapi

`any`

OpenAPI document (accepts JSON imports and typed documents)

##### nodes

`S`\[`"config"`\]\[`"nodes"`\]

Generated node map from codegen

#### Returns

[`StatelyBuilder`](../schema/stately.md#statelybuilder)\<`S`\>

## References

### coreSchemaUtils

Renames and re-exports [core/schema/utils](core/schema/utils.md)
