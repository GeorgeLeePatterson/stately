//! Core traits for state management

use serde::{Deserialize, Serialize};

use crate::entity::{EntityId, Summary};

/// Trait that all state entities must implement.
///
/// This trait defines the core behavior of an entity, including:
/// - Type identification via `STATE_ENTRY`
/// - Human-readable name and description
/// - Summary generation for listings
///
/// Typically implemented via the `#[stately::entity]` proc macro.
pub trait StateEntity: Clone + Serialize + for<'de> Deserialize<'de> {
    /// The type identifier for this entity (e.g., "pipeline", "source")
    const STATE_ENTRY: &'static str;

    /// Returns the human-readable name of this entity instance
    fn name(&self) -> &str;

    /// Returns an optional description of this entity instance
    fn description(&self) -> Option<&str> { None }

    /// Returns a summary of this entity for listings
    fn summary(&self, id: EntityId) -> Summary {
        Summary {
            id,
            name: self.name().to_string(),
            description: self.description().map(ToString::to_string),
        }
    }
}

/// Trait for collections of entities.
///
/// This trait defines CRUD operations for managing a collection of entities
/// of a specific type. Collections are typically stored in a `State` struct
/// and provide operations like:
/// - Creating new entities
/// - Reading entities by ID or name
/// - Updating existing entities
/// - Deleting entities
/// - Listing and searching entities
pub trait StateCollection {
    /// The entity type stored in this collection
    type Entity: StateEntity;

    /// The type identifier for this collection's entities
    const STATE_ENTRY: &'static str;

    /// Loads a collection from a list of entities and IDs
    fn load<I>(entities: I) -> Self
    where
        I: IntoIterator<Item = (EntityId, Self::Entity)>;

    /// Gets an entity by ID or name
    fn get_entity(&self, id: &str) -> Option<(&EntityId, &Self::Entity)>;

    /// Gets all entities in the collection
    fn get_entities(&self) -> Vec<(&EntityId, &Self::Entity)>;

    /// Searches entities by a needle string (matches against name/description)
    fn search_entities(&self, needle: &str) -> Vec<(&EntityId, &Self::Entity)>;

    /// Creates a new entity in the collection, returning its ID
    fn create(&mut self, entity: Self::Entity) -> EntityId;

    /// Updates an existing entity by ID
    ///
    /// # Errors
    ///
    /// Returns an error if the entity with the given ID does not exist in the collection.
    fn update(&mut self, id: &str, entity: Self::Entity) -> Result<Self::Entity, String>;

    /// Removes an entity by ID
    ///
    /// # Errors
    ///
    /// Returns an error if the entity with the given ID does not exist in the collection.
    /// For singletons, always returns an error as they cannot be removed.
    fn remove(&mut self, id: &str) -> Result<Self::Entity, String>;

    /// Lists all entities as summaries
    fn list(&self) -> Vec<Summary>;

    /// Checks if the collection is empty
    fn is_empty(&self) -> bool;
}

/// Trait for application state structs generated by `#[stately::state]`.
///
/// This trait is automatically implemented by the `#[stately::state]` proc macro
/// and provides a unified interface for working with application state in generic contexts,
/// such as web API handlers.
///
/// The trait is generic over the specific `StateEntry` and `Entity` enums that are
/// generated for each application, allowing type-safe CRUD operations.
#[cfg(feature = "axum")]
pub trait StatelyState: Send + Sync + 'static {
    /// The generated `StateEntry` enum type for this state
    type StateEntry: Clone
        + Eq
        + std::hash::Hash
        + Serialize
        + for<'de> Deserialize<'de>
        + std::str::FromStr;

    /// The generated `Entity` enum type for this state
    type Entity: Clone + Serialize + for<'de> Deserialize<'de>;

    /// Creates a new entity
    ///
    /// # Arguments
    /// * `entity` - The entity to create
    ///
    /// # Returns
    /// The entity identifier and optional message, or an error
    ///
    /// # Errors
    /// * The entity already exists or the entity is invalid
    fn create_entity(&mut self, entity: Self::Entity)
    -> Result<(EntityId, Option<String>), String>;

    /// Updates an existing entity by ID or name
    ///
    /// # Arguments
    /// * `id` - The entity ID or name to update
    /// * `entity` - The updated entity data
    ///
    /// # Returns
    /// The entity identifier and optional message, or an error
    ///
    /// # Errors
    /// * The entity does not exist or the entity is invalid
    fn update_entity(
        &mut self,
        id: &str,
        entity: Self::Entity,
    ) -> Result<(EntityId, Option<String>), String>;

    /// Removes an entity by ID or name and type
    ///
    /// # Arguments
    /// * `id` - The entity ID or name to remove
    /// * `entry` - The type of entity to remove
    ///
    /// # Returns
    /// Optional message on success, or an error
    ///
    /// # Errors
    /// * The entity does not exist
    fn remove_entity(
        &mut self,
        id: &str,
        entry: Self::StateEntry,
    ) -> Result<Option<String>, String>;

    /// Gets an entity by ID or name and type
    ///
    /// # Arguments
    /// * `id` - The entity ID or name to look up
    /// * `entry` - The type of entity to retrieve
    ///
    /// # Returns
    /// The entity identifier and entity if found
    fn get_entity(&self, id: &str, entry: Self::StateEntry) -> Option<(EntityId, Self::Entity)>;

    /// Lists all entities, optionally filtered by type
    ///
    /// # Arguments
    /// * `entry` - Optional entity type to filter by. If `None`, returns all entities.
    ///
    /// # Returns
    /// A map of entity types to their summaries
    fn list_entities(
        &self,
        entry: Option<Self::StateEntry>,
    ) -> hashbrown::HashMap<Self::StateEntry, Vec<Summary>>;

    /// Searches for entities across all collections
    ///
    /// # Arguments
    /// * `needle` - The search string to match against entity names and descriptions
    ///
    /// # Returns
    /// A map of entity types to maps of entity IDs to entities
    fn search_entities(
        &self,
        needle: &str,
    ) -> hashbrown::HashMap<Self::StateEntry, hashbrown::HashMap<EntityId, Self::Entity>>;
}

//----
// Blanket impls
//----
impl<T: StateCollection> StateCollection for Box<T> {
    type Entity = T::Entity;

    const STATE_ENTRY: &'static str = T::STATE_ENTRY;

    fn load<I>(entities: I) -> Self
    where
        I: IntoIterator<Item = (EntityId, Self::Entity)>,
    {
        Box::new(T::load(entities))
    }

    fn get_entity(&self, id: &str) -> Option<(&EntityId, &Self::Entity)> {
        self.as_ref().get_entity(id)
    }

    fn get_entities(&self) -> Vec<(&EntityId, &Self::Entity)> { self.as_ref().get_entities() }

    fn search_entities(&self, needle: &str) -> Vec<(&EntityId, &Self::Entity)> {
        self.as_ref().search_entities(needle)
    }

    fn create(&mut self, entity: Self::Entity) -> EntityId { self.as_mut().create(entity) }

    fn update(&mut self, id: &str, entity: Self::Entity) -> Result<Self::Entity, String> {
        self.as_mut().update(id, entity)
    }

    fn remove(&mut self, id: &str) -> Result<Self::Entity, String> { self.as_mut().remove(id) }

    fn list(&self) -> Vec<Summary> { self.as_ref().list() }

    fn is_empty(&self) -> bool { self.as_ref().is_empty() }
}
