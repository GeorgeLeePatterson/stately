# Example: Entity Metadata with Generic Schema Types

This shows how the entity-metadata logic from xeo4 would be ported to use generic schema types.

## Original xeo4 Code (Hardcoded)

```typescript
// xeo4/ui/src/lib/entity-metadata.ts
import type { components } from '@/types/api';
import openapi from '@/../openapi.json'; // ← Hardcoded to xeo4's openapi.json

export type StateEntry = components['schemas']['StateEntry'];
export type Entity = components['schemas']['Entity'];

// Hardcoded extraction from xeo4's openapi.json
const entitySchema = openapi.components?.schemas?.Entity;
const ENTITY_MAPPINGS = /* extract from openapi.json */;

export const STATE_ENTRY_TO_SCHEMA: Record<StateEntry, string> = /* ... */;
```

## New Generic Version (User-Provided)

```typescript
// User's application code (e.g., in @your/ui package)
import type { components } from './types/api'; // YOUR api.ts
import openapi from './openapi.json'; // YOUR openapi.json
import type { 
  StatelySchemas,
  AnySchemaNode,
  ExtractStateEntry,
  ExtractEntity
} from '@stately/schema-types';

// 1. Define your schema constraint
type MySchemas = {
  StateEntry: components['schemas']['StateEntry'];
  Entity: components['schemas']['Entity'];
  EntityId: components['schemas']['EntityId'];
};

// 2. Extract type-safe aliases
type StateEntry = ExtractStateEntry<MySchemas>;
type Entity = ExtractEntity<MySchemas>;
type EntityData = Entity['data'];

// 3. Entity mapping interface (same as before)
interface EntityMapping {
  stateEntry: StateEntry; // ← Now YOUR StateEntry, not xeo4's
  schemaName: string;
}

// 4. Extract mappings from YOUR openapi.json (same logic as xeo4)
const entitySchema = openapi.components?.schemas?.Entity;
if (!entitySchema?.oneOf) {
  throw new Error('Entity schema not found in OpenAPI spec');
}

const ENTITY_MAPPINGS: EntityMapping[] = entitySchema.oneOf.map(variant => {
  const stateEntry = variant.properties.type.enum[0] as StateEntry;
  const schemaName = variant.properties.data.$ref.split('/').pop() || '';
  return { stateEntry, schemaName };
});

// 5. Build mappings (same as xeo4, but type-safe to YOUR schemas)
export const STATE_ENTRY_TO_SCHEMA: Record<StateEntry, string> = 
  Object.fromEntries(
    ENTITY_MAPPINGS.map(({ stateEntry, schemaName }) => [stateEntry, schemaName])
  ) as Record<StateEntry, string>;

// 6. Import YOUR generated schemas
import { PARSED_SCHEMAS, type ParsedSchemaName } from './generated-schemas';

// 7. Build entity schema cache (same logic, YOUR types)
export const ENTITY_SCHEMA_CACHE: Record<StateEntry, AnySchemaNode<MySchemas> | null> = 
  Object.entries(STATE_ENTRY_TO_SCHEMA).reduce(
    (acc, [stateEntry, schemaName]) => {
      const schema = PARSED_SCHEMAS[schemaName as ParsedSchemaName];
      if (!schema) {
        console.error(`Schema not found for ${stateEntry} (${schemaName})`);
      }
      acc[stateEntry as StateEntry] = schema || null;
      return acc;
    },
    {} as Record<StateEntry, AnySchemaNode<MySchemas> | null>
  );

// 8. URL mappings (same logic as xeo4)
export const URL_TO_STATE_ENTRY: Record<string, StateEntry> = 
  Object.fromEntries(
    ENTITY_MAPPINGS.map(({ stateEntry }) => [toKebabCase(stateEntry), stateEntry])
  ) as Record<string, StateEntry>;

export const STATE_ENTRY_TO_URL: Record<StateEntry, string> = 
  Object.fromEntries(
    ENTITY_MAPPINGS.map(({ stateEntry }) => [stateEntry, toKebabCase(stateEntry)])
  ) as Record<StateEntry, string>;

// 9. Display names (same logic as xeo4)
export const ENTITY_DISPLAY_NAMES: Record<StateEntry, string> = 
  Object.fromEntries(
    ENTITY_MAPPINGS.map(({ stateEntry }) => [stateEntry, toTitleCase(stateEntry)])
  ) as Record<StateEntry, string>;
```

## Key Differences

### Before (xeo4)
```typescript
import type { StateEntry } from './entity-metadata'; // Hardcoded
import type { AnySchemaNode } from './schema-nodes'; // Not generic

const schema: AnySchemaNode = /* ... */; // Works only for xeo4
```

### After (Generic)
```typescript
import type { StateEntry } from './my-entity-metadata'; // Your types
import type { AnySchemaNode } from '@stately/schema-types'; // Generic

type MySchemas = { /* ... */ };
const schema: AnySchemaNode<MySchemas> = /* ... */; // Works for YOUR app
```

## Where the Code Lives

The key realization is that **entity-metadata is APPLICATION CODE**, not library code:

```
xeo4/                           (Your application)
├── openapi.json               ← YOUR OpenAPI spec
├── src/
│   ├── types/
│   │   └── api.ts            ← YOUR generated types
│   ├── lib/
│   │   ├── generated-schemas.ts  ← Generated by @stately/codegen
│   │   └── entity-metadata.ts    ← Application code using @stately/schema-types
│   └── components/
│       └── EntityEditor.tsx  ← Uses entity-metadata
└── package.json
    └── "@stately/schema-types": "^0.3.0"
    └── "@stately/codegen": "^0.3.0"
    └── "@stately/ui": "^0.3.0"
```

The `@stately/*` packages don't contain entity-metadata - **you do**. The packages just provide:
- `@stately/schema-types`: Generic type definitions
- `@stately/codegen`: CLI tool to generate schemas
- `@stately/ui`: React components that consume YOUR entity-metadata

## Type Flow Diagram

```
OpenAPI Spec (openapi.json)
    ↓
openapi-typescript
    ↓
components['schemas'] (api.ts)
    ↓
MySchemas type constraint
    ↓
@stately/schema-types (generic types)
    ↓
@stately/codegen (generates schemas)
    ↓
Your entity-metadata.ts (mappings)
    ↓
@stately/ui components (rendering)
```

At every step, TypeScript understands:
- StateEntry is YOUR specific union, not "string"
- Entity is YOUR specific tagged union
- Link<T> targets YOUR entity types
- Everything is type-safe end-to-end

## Benefits of This Approach

1. **No Hardcoding**: @stately packages work with ANY Stately backend
2. **Type Safety**: Full type safety from OpenAPI → UI components
3. **Semantic Preservation**: StateEntry meaning is never lost
4. **Reusable**: Same packages work for xeo4, future projects, other users
5. **Maintainable**: User code stays in sync with their OpenAPI spec
6. **Composable**: Can mix multiple Stately backends in one app (advanced)

## Migration Strategy

For porting xeo4 → @stately/ui:

1. **Keep entity-metadata.ts in xeo4** (it's application code)
2. **Make it consume @stately/schema-types** (add generic parameters)
3. **Port UI components to @stately/ui** (make them accept entity-metadata)
4. **xeo4 imports and provides its own entity-metadata to @stately/ui**

This way:
- @stately/ui is generic and reusable
- xeo4 maintains its own entity-metadata
- Full type safety is preserved
- No functionality is lost
