import type { OpenAPIV3_1 } from 'openapi-types';
import type { AnyRecord, EmptyRecord, StringKeys } from './helpers';
import type { BaseNode, NodeMap } from './nodes';

/**
 * Base provided configuration
 *
 * Accepts generated TypeScript types from openapi-typescript (not raw OpenAPI structure).
 * The type system uses clean generated types for type safety, while runtime introspection
 * uses the raw OpenAPI document passed to stately().
 *
 * Variance annotations enforce that Config can only be used in covariant (output) positions.
 * This prevents accidentally using patterns like `keyof Config['nodes']` which create
 * invariant constraints and break subtype compatibility.
 */
export interface StatelyConfig<
  out Components = { schemas?: AnyRecord },
  out Paths extends {} = EmptyRecord,
  out Nodes extends NodeMap = NodeMap,
> {
  components: Components;
  paths: Paths;
  nodes: Nodes;
}

export interface BaseConfig {
  components: { schemas?: AnyRecord };
  paths: AnyRecord;
  nodes: NodeMap;
}

/**
 * Define the Config
 *
 * @example
 * ```typescript
 * type MyStatelyConfig = DefineStatelyConfig<{
 *   components: {},
 *   paths: {},
 *   nodes: {},
 * }>;
 * ```
 */
export type DefineStatelyConfig<
  C extends DefineComponents = DefineComponents,
  P extends DefinePaths = DefinePaths,
  N extends DefineGeneratedNodes<NodeMap> = DefineGeneratedNodes<NodeMap>,
> = StatelyConfig<C, P, N>;

/**
 * =============================================================================
 * CONFIG DEFINITION HELPERS - "Fill in the form" types for StatelyConfig
 * =============================================================================
 * These helpers guide plugin authors to define the correct types for configs
 * that their plugins expect. Use these when creating custom config types.
 *
 * These accept generated TypeScript types from openapi-typescript, not raw OpenAPI structure.
 */

/**
 * Define the components structure your plugin expects.
 * Typically generated by openapi-typescript with a schemas property.
 *
 * @example
 * ```typescript
 * type MyComponents = DefineComponents<{
 *   schemas: {
 *     MyEntity: { id: string; name: string };
 *     MyOtherType: { value: number };
 *   }
 * }>;
 * ```
 */
export type DefineComponents<
  T extends { schemas?: Record<string, any> } = { schemas?: Record<string, any> },
> = T;

/**
 * Define the component schemas structure your plugin expects.
 * Use this when you only care about schemas, not the full components object.
 *
 * @example
 * ```typescript
 * type MyComponentsSchemas = DefineComponentSchemas<{
 *   MyEntity: { id: string; name: string };
 *   MyOtherType: { value: number };
 * }>;
 * ```
 */
export type DefineComponentSchemas<T extends Record<string, any> = Record<string, any>> = T;

/**
 * Define the paths structure your plugin expects.
 * Typically generated by openapi-typescript as a record of path strings to operations.
 *
 * @example
 * ```typescript
 * type MyPaths = DefinePaths<{
 *   '/api/users': {
 *     get: { responses: { 200: { content: { 'application/json': User[] } } } };
 *   };
 * }>;
 * ```
 */
export type DefinePaths<T extends Record<string, any> = Record<string, any>> = T;

/**
 * Define the generated node structure your plugin expects.
 * All nodes must extend BaseNode.
 *
 * @example
 * ```typescript
 * type MyGeneratedNodes = DefineGeneratedNodes<{
 *   User: ObjectNode;
 *   Post: ObjectNode;
 * }>;
 * ```
 */
export type DefineGeneratedNodes<T extends NodeMap = NodeMap> = T;

export type GeneratedNodeMap<Config extends StatelyConfig> = Config['nodes'] extends Record<
  string,
  any
>
  ? {
      [K in StringKeys<Config['nodes']>]: Config['nodes'][K] extends BaseNode
        ? Config['nodes'][K]
        : never;
    }
  : NodeMap;

/**
 * Helper type to ensure OpenAPI spec is typed properly.
 * Accepts JSON imports with readonly modifiers and typed documents.
 *
 * @example
 * ```typescript
 * import openapiDoc from './openapi.json';
 * const doc: DefineOpenApi<typeof openapiDoc> = openapiDoc;
 * ```
 */
export type DefineOpenApi<T> = T extends OpenAPIV3_1.Document
  ? T
  : T extends Record<string, any>
    ? T & Partial<OpenAPIV3_1.Document>
    : OpenAPIV3_1.Document;
