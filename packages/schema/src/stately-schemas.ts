/**
 * Core Schema Interface - Single Source of Truth
 *
 * This interface defines the REQUIRED subset of components["schemas"] that
 * Stately UI packages depend on. It acts as a contract between the backend
 * (Rust + OpenAPI generation) and the frontend (TypeScript UI).
 *
 * Design Principles:
 * 1. This is a SUBSET of components["schemas"] - we only require what we need
 * 2. As we discover new required types, we ADD them here and they CASCADE
 * 3. ALL type derivations MUST be based on this interface
 * 4. The relationship Entity.type === StateEntry is ENFORCED by OpenAPI and we preserve it
 *
 * Why this works:
 * - Rust macros generate StateEntry enum and Entity enum from the SAME source
 * - OpenAPI captures this relationship (Entity oneOf variants use StateEntry values)
 * - openapi-typescript preserves it (Entity is tagged union with literal types)
 * - We enforce it here with TypeScript's type system
 */

/**
 * Base constraint that ALL schema types must extend
 * This allows us to reference components["schemas"] structurally
 */
export interface ComponentSchemas {
  [key: string]: any;
}

/**
 * Core Stately schemas required by UI packages
 *
 * This interface accepts TWO inputs:
 * 1. components: Raw OpenAPI schemas (components["schemas"])
 * 2. nodes: Generated schema AST nodes (typeof PARSED_SCHEMAS)
 *
 * IMPORTANT: This interface ENFORCES the critical relationship:
 *   Entity['type'] === StateEntry
 *
 * This relationship is guaranteed by:
 * 1. Rust: Proc macros generate both from same source
 * 2. OpenAPI: Entity oneOf variants use StateEntry enum values
 * 3. openapi-typescript: Preserves tagged union with literal types
 * 4. TypeScript (here): We validate and enforce it
 */

export interface StatelySchemas<
  Schemas extends ComponentSchemas = ComponentSchemas,
  Nodes extends Record<string, any> = Record<string, any>
> {
  /**
   * The component schemas from OpenAPI (via openapi-typescript)
   * User provides: components["schemas"]
   */
  components: Schemas;

  /**
   * Generated schema nodes - cast to preserve keys
   * Input: typeof PARSED_SCHEMAS (Record<string, any>)
   * The actual typing of node values as AnySchemaNode happens in index.ts
   * This just preserves the Record shape with the correct keys
   */
  nodes: Nodes;

  /**
   * StateEntry: The canonical enum mapping entity types to state properties
   *
   * NOT just "string" - this is THE discriminator for all entity types.
   * In Rust: Generated by #[state] macro
   * In OpenAPI: { type: "string", enum: [...] }
   * In TypeScript: 'pipeline' | 'source_config' | ...
   *
   * Extracted from: components["schemas"]["StateEntry"]
   */
  StateEntry: Schemas['StateEntry'];

  /**
   * Entity: Tagged union wrapper for generic CRUD operations
   *
   * Structure: { type: StateEntry, data: EntityData }
   * In Rust: Generated by #[state] macro, uses #[serde(tag = "type", content = "data")]
   * In OpenAPI: oneOf with discriminator
   * In TypeScript: Union of { type: literal, data: specific }
   *
   * CRITICAL CONSTRAINT: Entity['type'] must equal StateEntry
   * This is enforced by ValidateEntityType below
   *
   * Extracted from: components["schemas"]["Entity"]
   */
  Entity: Schemas['Entity'];

  /**
   * EntityId: Unique identifier for entities (UUID v7)
   *
   * In Rust: newtype wrapper around Uuid
   * In OpenAPI: { type: "string", format: "uuid" }
   * In TypeScript: string
   *
   * Extracted from: components["schemas"]["EntityId"]
   */
  EntityId: Schemas['EntityId'];

  /**
   * Schema names: All keys from the generated schemas
   * Used for RecursiveRefNode.refName typing
   */
  NodeNames: keyof Nodes;
}

/**
 * Validate that Entity.type equals StateEntry
 * This enforces the critical relationship at the type level
 *
 * Note: We use a helper type to extract the union of 'type' values from Entity
 * because direct inference with 'extends { type: infer T }' doesn't distribute properly
 */
type ExtractEntityTypeField<E> = E extends { type: infer T } ? T : never;

type ValidateEntityType<S extends StatelySchemas> =
  // Check bidirectional equality: Entity.type === StateEntry
  ExtractEntityTypeField<S['Entity']> extends S['StateEntry']
    ? S['StateEntry'] extends ExtractEntityTypeField<S['Entity']>
      ? S  // ✓ Bidirectional match: Entity.type === StateEntry
      : never  // ✗ StateEntry has values not in Entity.type
    : never;  // ✗ Entity.type has values not in StateEntry

/**
 * Validated StatelySchemas - use this in all public APIs
 * This ensures the Entity.type === StateEntry constraint is checked
 */
export type ValidatedStatelySchemas<S extends StatelySchemas> = ValidateEntityType<S>;

/**
 * Extract StateEntry from validated schemas
 * This gives you the exact union type, not just "string"
 */
export type ExtractStateEntry<S extends StatelySchemas> =
  ValidatedStatelySchemas<S>['StateEntry'];

/**
 * Extract Entity from validated schemas
 * This gives you the exact tagged union
 */
export type ExtractEntity<S extends StatelySchemas> =
  ValidatedStatelySchemas<S>['Entity'];

/**
 * Extract EntityData (union of all entity data types)
 * Useful for generic handling of entity payloads
 */
export type ExtractEntityData<S extends StatelySchemas> =
  ValidatedStatelySchemas<S>['Entity'] extends { data: infer D } ? D : never;

/**
 * Extract EntityId from validated schemas
 */
export type ExtractEntityId<S extends StatelySchemas> =
  ValidatedStatelySchemas<S>['EntityId'];

/**
 * Extract the full components["schemas"] object
 * Useful when you need to reference other schemas
 */
export type ExtractComponents<S extends StatelySchemas> = S['components'];

/**
 * Helper: Get entity data type for a specific StateEntry value
 * Example: EntityDataForType<MySchemas, 'pipeline'> = Pipeline
 */
export type EntityDataForType<
  S extends StatelySchemas,
  Type extends ExtractStateEntry<S>
> = Extract<ExtractEntity<S>, { type: Type }> extends { data: infer D } ? D : never;

/**
 * Helper: Check if a type is a valid StateEntry value
 */
export type IsValidStateEntry<
  S extends StatelySchemas,
  T extends string
> = T extends ExtractStateEntry<S> ? true : false;
