# Stately OpenAPI Contract

// TODO! Remove - Update! Very Important!

This document defines the **contract** that any OpenAPI specification generated by a Stately Rust application MUST satisfy for the TypeScript UI packages to work correctly.

## Overview

When you use `#[stately::state]` and `#[stately::axum_api(openapi)]` in your Rust code, Stately generates specific types and schemas in the OpenAPI specification. The `@stately/ui` packages depend on these types existing with specific structures.

## Required Components

### 1. `StateEntry` - Entity Type Discriminator

**Location**: `components.schemas.StateEntry`

**Structure**:
```json
{
  "type": "string",
  "enum": ["entity_type_1", "entity_type_2", ...]
}
```

**Semantic Meaning**:
- The complete set of entity types managed by your Stately state
- Each value corresponds to a `#[collection]` in your `State` struct
- Used as a discriminator for type-safe entity operations

**TypeScript Type** (generated by `openapi-typescript`):
```typescript
type StateEntry = "entity_type_1" | "entity_type_2" | ...;
```

**Example**:
```json
{
  "StateEntry": {
    "type": "string",
    "enum": ["pipeline", "source", "sink"]
  }
}
```

**Generated By**:
- Rust macro: `#[stately::state]`
- Feature: `openapi` (adds `utoipa::ToSchema` derive)

---

### 2. `Entity` - Tagged Union of All Entities

**Location**: `components.schemas.Entity`

**Structure**:
```json
{
  "oneOf": [
    {
      "type": "object",
      "required": ["type", "data"],
      "properties": {
        "type": { "type": "string", "enum": ["entity_type_1"] },
        "data": { "$ref": "#/components/schemas/EntityType1" }
      }
    },
    // ... one variant per StateEntry value
  ]
}
```

**Semantic Meaning**:
- Type-erased wrapper for any entity type
- Allows passing different entity types through a common interface
- Preserves type information via the `type` discriminator

**TypeScript Type** (generated by `openapi-typescript`):
```typescript
type Entity =
  | { type: "entity_type_1", data: EntityType1 }
  | { type: "entity_type_2", data: EntityType2 }
  | ...;
```

**Example**:
```json
{
  "Entity": {
    "oneOf": [
      {
        "type": "object",
        "required": ["type", "data"],
        "properties": {
          "type": { "enum": ["pipeline"] },
          "data": { "$ref": "#/components/schemas/Pipeline" }
        }
      },
      {
        "type": "object",
        "required": ["type", "data"],
        "properties": {
          "type": { "enum": ["source"] },
          "data": { "$ref": "#/components/schemas/Source" }
        }
      }
    ]
  }
}
```

**Generated By**:
- Rust macro: `#[stately::state]`
- Feature: `openapi`

---

### 3. `EntityId` - Entity Identifier

**Location**: `components.schemas.EntityId`

**Structure**:
```json
{
  "type": "string",
  "description": "Entity identifier type - UUID v7 format"
}
```

**Semantic Meaning**:
- Unique identifier for entities
- Uses UUID v7 (time-sortable)
- Special singleton ID: `"00000000-0000-0000-0000-000000000000"`

**TypeScript Type**:
```typescript
type EntityId = string;
```

**Generated By**:
- Stately core library (always present)

---

### 4. `Link<T>` - Entity References

**Location**: `components.schemas.Link{EntityType}` (one per entity type)

**Structure**:
```json
{
  "oneOf": [
    {
      "type": "object",
      "required": ["entity_type", "ref"],
      "properties": {
        "entity_type": { "enum": ["entity_type"] },
        "ref": { "type": "string" }
      }
    },
    {
      "type": "object",
      "required": ["entity_type", "inline"],
      "properties": {
        "entity_type": { "enum": ["entity_type"] },
        "inline": { "$ref": "#/components/schemas/EntityType" }
      }
    }
  ]
}
```

**Semantic Meaning**:
- Reference to another entity (either by ID or inline data)
- Preserves type safety (knows target entity type)
- Supports two modes:
  - `ref`: Just store the entity ID (entity defined elsewhere)
  - `inline`: Embed the full entity data

**TypeScript Type**:
```typescript
type LinkEntityType =
  | { entity_type: "entity_type", ref: string }
  | { entity_type: "entity_type", inline: EntityType };
```

**Example**:
```json
{
  "LinkPipeline": {
    "oneOf": [
      {
        "properties": {
          "entity_type": { "enum": ["pipeline"] },
          "ref": { "type": "string" }
        }
      },
      {
        "properties": {
          "entity_type": { "enum": ["pipeline"] },
          "inline": { "$ref": "#/components/schemas/Pipeline" }
        }
      }
    ]
  }
}
```

**Generated By**:
- Stately core library when you use `Link<T>` in entity definitions
- Feature: `openapi`

---

### 5. Entity Data Schemas

**Location**: `components.schemas.{EntityType}` (one per entity)

**Structure**: Defined by your entity structs

**Semantic Meaning**:
- The actual data structure for each entity type
- Must have a `name` field (unless it's a singleton)
- Can contain any valid OpenAPI schema types

**Example**:
```json
{
  "Pipeline": {
    "type": "object",
    "required": ["name", "source"],
    "properties": {
      "name": { "type": "string" },
      "source": { "$ref": "#/components/schemas/LinkSource" }
    }
  }
}
```

**Generated By**:
- Your entity struct definitions
- `#[derive(utoipa::ToSchema)]` on entity types
- Feature: `openapi`

---

## Validation

The `@stately/codegen` package validates that your OpenAPI spec satisfies this contract before generating schemas. If required types are missing or malformed, it will error with a helpful message.

### Runtime Checks

```typescript
import { validateStatelyContract } from '@stately/codegen';

// Throws if contract not satisfied
validateStatelyContract(openAPISpec);
```

### TypeScript Checks

```typescript
import type { components } from './api'; // Your generated api.ts
import type { StatelyApiContract } from '@stately/schema-types';

// Compile-time verification (will error if contract not satisfied)
type _Check = components extends StatelyApiContract ? true : false;
```

---

## Stately Version Compatibility

This contract is defined by **Stately v0.3.0+**

Older versions may not generate all required types. To ensure compatibility:

```toml
[dependencies]
stately = { version = "0.3", features = ["openapi", "axum"] }
```

---

## Why This Matters

By defining a clear contract:
- ✅ `@stately/ui` knows exactly what to expect
- ✅ Breaking changes to the contract are versioned
- ✅ TypeScript tooling can verify compatibility
- ✅ Error messages can be specific and helpful
- ✅ Future Stately releases can extend (not break) the contract

---

## Future Extensions

Potential additions to the contract (non-breaking):
- Response/Request types for API operations
- Summary type for list operations
- Event types for real-time updates
- Pagination metadata

These would be **additions**, not changes to existing types.
