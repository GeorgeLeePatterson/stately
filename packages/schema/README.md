# @stately/schema-types

Generic type definitions for Stately schema nodes that preserve semantic meaning across the type system.

## Overview

This package provides TypeScript types for representing OpenAPI schemas as an Abstract Syntax Tree (AST), with full type safety for Stately-specific contracts.

**Key Feature**: Enforces `Entity.type === StateEntry` at compile time, matching Rust's proc macro guarantees.

## Installation

```bash
pnpm add @stately/schema-types
```

## Quick Start

```typescript
import type { components } from './types/api'; // Generated by openapi-typescript
import type { 
  StatelySchemas, 
  ExtractStateEntry,
  LinkNode,
  AnySchemaNode 
} from '@stately/schema-types';

// 1. Define your schema constraint
type MySchemas = StatelySchemas<{
  StateEntry: components['schemas']['StateEntry'];
  Entity: components['schemas']['Entity'];
  EntityId: components['schemas']['EntityId'];
}>;

// 2. Extract type-safe values
type StateEntry = ExtractStateEntry<MySchemas>;
// Result: 'pipeline' | 'source_config' | ... (YOUR specific types)

// 3. Use in schema nodes
const link: LinkNode<MySchemas> = {
  nodeType: 'link',
  targetType: 'pipeline', // ✓ Type-safe!
  inlineSchema: { /* ... */ }
};
```

## Core Design Principle

**StatelySchemas is the SINGLE SOURCE OF TRUTH**

- All type derivations CASCADE from `StatelySchemas`
- `Entity.type === StateEntry` is ENFORCED (matching Rust guarantees)
- As we discover new required types, we ADD them to `StatelySchemas`
- Everything else derives from there

## The Critical Relationship

In Stately, these relationships are CRITICAL:

1. **StateEntry** = Canonical enum mapping actions to state properties
2. **Entity** = Tagged union wrapper: `{ type: StateEntry, data: EntityData }`
3. **Collection<T>** = State property with potential semantic wrapping
4. **Link<T>** = Reference using wrapper type (not raw type)

This package **preserves** these relationships through TypeScript's type system.

## Why This Matters

### ❌ Without Enforcement

```typescript
// StateEntry is just "string" - loses semantic meaning
interface LinkNode {
  targetType: string; // ❌ Any string accepted
}

const link: LinkNode = {
  targetType: 'typo' // ❌ No error - runtime bug!
};
```

### ✅ With Enforcement

```typescript
// StateEntry is YOUR specific union type
interface LinkNode<Schemas extends StatelySchemas> {
  targetType: ExtractStateEntry<Schemas>; // ✓ Only valid entity types
}

const link: LinkNode<MySchemas> = {
  targetType: 'typo' // ✓ Compile error - caught immediately!
  // Error: Type '"typo"' is not assignable to type '"pipeline" | "source_config" | ...
};
```

## Schema Node Types

All schema nodes are generic over `Schemas` to preserve type relationships:

- **PrimitiveNode** - string, number, integer, boolean
- **EnumNode** - Fixed set of string values
- **ObjectNode** - Struct with named properties
- **ArrayNode** - Vec<T>
- **MapNode** - HashMap<String, T> (keys can be constrained to StateEntry)
- **TupleNode** - Fixed-length heterogeneous array
- **TaggedUnionNode** - Rust enum with discriminator
- **UntaggedEnumNode** - Rust enum with inferred discriminator
- **LinkNode** - Reference OR inline (targetType is StateEntry)
- **NullableNode** - Option<T>
- **RecursiveRefNode** - Breaks circular references
- **RelativePathNode** - Managed application paths

## Type Helpers

```typescript
// Extract types from your schemas
type StateEntry = ExtractStateEntry<MySchemas>;
type Entity = ExtractEntity<MySchemas>;
type EntityData = ExtractEntityData<MySchemas>;
type EntityId = ExtractEntityId<MySchemas>;

// Get data type for specific entity
type PipelineData = EntityDataForType<MySchemas, 'pipeline'>;

// Check if value is valid StateEntry
type IsValid = IsValidStateEntry<MySchemas, 'pipeline'>; // true
type IsInvalid = IsValidStateEntry<MySchemas, 'typo'>; // false
```

## Validation

The package validates that `Entity.type === StateEntry` at compile time:

```typescript
// ✓ Valid: Entity.type matches StateEntry
interface GoodComponents {
  StateEntry: 'a' | 'b';
  Entity: { type: 'a'; data: any } | { type: 'b'; data: any };
  EntityId: string;
}

// ❌ Invalid: Entity has extra type not in StateEntry
interface BadComponents {
  StateEntry: 'a' | 'b';
  Entity: 
    | { type: 'a'; data: any } 
    | { type: 'b'; data: any }
    | { type: 'c'; data: any }; // ← Not in StateEntry!
  EntityId: string;
}

type Bad = StatelySchemas<BadComponents>;
type Invalid = ExtractStateEntry<Bad>; // Result: never (validation failed)
```

## Integration with @stately/codegen

Use `@stately/codegen` to generate schema nodes from your OpenAPI spec:

```bash
$ npx stately-codegen openapi.json --output src/generated-schemas.ts
```

This generates:

```typescript
import type { components } from './api';
import type { StatelySchemas, AnySchemaNode } from '@stately/schema-types';

type MySchemas = StatelySchemas<{
  StateEntry: components['schemas']['StateEntry'];
  Entity: components['schemas']['Entity'];
  EntityId: components['schemas']['EntityId'];
}>;

export const PARSED_SCHEMAS: Record<string, AnySchemaNode<MySchemas>> = {
  // ... generated schema nodes
};
```

## Benefits

1. ✅ **Type-safe everywhere**: Routes, hooks, parsing, rendering
2. ✅ **Semantic preservation**: StateEntry isn't "string", it's YOUR entity types
3. ✅ **Zero runtime overhead**: Pure TypeScript, compiles to same JavaScript
4. ✅ **Compile-time validation**: Typos caught by tsc, not at runtime
5. ✅ **Excellent IDE support**: Autocomplete, go-to-definition, refactoring
6. ✅ **Reusable**: Works with ANY Stately backend, not hardcoded

## Documentation

- [Usage Guide](./USAGE.md) - Detailed usage patterns
- [Type System Design](./TYPE_SYSTEM_DESIGN.md) - Architecture deep dive
- [Type Enforcement](./TYPE_ENFORCEMENT_WORKS.md) - Validation examples
- [Example: Entity Metadata](./EXAMPLE_ENTITY_METADATA.md) - Real-world usage
- [Stately Contract](./STATELY_CONTRACT.md) - Required OpenAPI types

## License

Apache-2.0

## Contributing

This package is part of the [Stately](https://github.com/georgeleepatterson/stately) monorepo.
