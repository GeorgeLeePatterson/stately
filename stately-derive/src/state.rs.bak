//! Implementation of the `#[stately::state]` attribute macro

use proc_macro::TokenStream;
use quote::quote;
use syn::{Data, DeriveInput, Fields};

/// Generates application state with entity collections.
pub fn state(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = syn::parse_macro_input!(item as DeriveInput);

    let vis = &input.vis;
    let name = &input.ident;

    // Parse the struct fields
    let fields = match &input.data {
        Data::Struct(data) => match &data.fields {
            Fields::Named(fields) => &fields.named,
            _ => {
                return syn::Error::new_spanned(
                    &input,
                    "State can only be derived for structs with named fields",
                )
                .to_compile_error()
                .into();
            }
        },
        _ => {
            return syn::Error::new_spanned(&input, "State can only be derived for structs")
                .to_compile_error()
                .into();
        }
    };

    // Separate singletons from collections
    let mut singletons = Vec::new();
    let mut collections = Vec::new();

    for field in fields {
        let field_name = field.ident.as_ref().unwrap();
        let field_type = &field.ty;

        // Check if this field has #[singleton] attribute
        let is_singleton = field.attrs.iter().any(|attr| attr.path().is_ident("singleton"));

        if is_singleton {
            singletons.push((field_name, field_type));
        } else {
            collections.push((field_name, field_type));
        }
    }

    // Extract type identifiers for enum variants
    let singleton_variants: Vec<_> =
        singletons.iter().map(|(_, ty)| extract_type_ident(ty)).collect();

    let collection_variants: Vec<_> =
        collections.iter().map(|(_, ty)| extract_type_ident(ty)).collect();

    // Collect everything into vectors for reuse in the quote! macro
    let all_variants: Vec<_> =
        singleton_variants.iter().chain(&collection_variants).cloned().collect();
    let all_types: Vec<_> = singletons
        .iter()
        .map(|(_, ty)| *ty)
        .chain(collections.iter().map(|(_, ty)| *ty))
        .collect();

    let singleton_fields: Vec<_> = singletons.iter().map(|(name, _)| *name).collect();
    let singleton_types: Vec<_> = singletons.iter().map(|(_, ty)| *ty).collect();

    let collection_fields: Vec<_> = collections.iter().map(|(name, _)| *name).collect();
    let collection_types: Vec<_> = collections.iter().map(|(_, ty)| *ty).collect();

    // Generate the core state code
    let core_code = quote! {
        // Generate StateEntry enum
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, ::serde::Serialize, ::serde::Deserialize)]
        #[cfg_attr(feature = "openapi", derive(::utoipa::ToSchema))]
        #[serde(rename_all = "snake_case")]
        #vis enum StateEntry {
            #( #all_variants, )*
        }

        impl StateEntry {
            #vis fn as_ref(&self) -> &str {
                match self {
                    #( Self::#all_variants => <#all_types as ::stately::StateEntity>::STATE_ENTRY, )*
                }
            }
        }

        impl ::std::str::FromStr for StateEntry {
            type Err = String;

            fn from_str(s: &str) -> ::std::result::Result<Self, Self::Err> {
                match s {
                    #( <#all_types as ::stately::StateEntity>::STATE_ENTRY => Ok(Self::#all_variants), )*
                    _ => Err(format!("Unknown entity type: {}", s)),
                }
            }
        }

        // Generate Entity enum
        #[derive(Debug, Clone, PartialEq, ::serde::Serialize, ::serde::Deserialize)]
        #[cfg_attr(feature = "openapi", derive(::utoipa::ToSchema))]
        #[serde(tag = "type", content = "data", rename_all = "snake_case")]
        #vis enum Entity {
            #( #all_variants(#all_types), )*
        }

        // Generate the State struct
        #vis struct #name {
            #( #vis #singleton_fields: ::stately::Singleton<#singleton_types>, )*
            #( #vis #collection_fields: ::stately::Collection<#collection_types>, )*
        }

        impl Default for #name {
            fn default() -> Self {
                Self::new()
            }
        }

        impl #name {
            /// Creates a new empty state
            #vis fn new() -> Self {
                Self {
                    #( #singleton_fields: ::stately::Singleton::new(Default::default()), )*
                    #( #collection_fields: ::stately::Collection::new(), )*
                }
            }

            /// Creates a new entity
            #vis fn create_entity(&mut self, entity: Entity) -> ::std::result::Result<(::stately::EntityIdentifier, Option<String>), String> {
                use ::stately::StateCollection;
                match entity {
                    #(
                        Entity::#singleton_variants(inner) => {
                            let id = self.#singleton_fields.create(inner);
                            Ok((id, Some("Entity created successfully".to_string())))
                        }
                    )*
                    #(
                        Entity::#collection_variants(inner) => {
                            let id = self.#collection_fields.create(inner);
                            Ok((id, Some("Entity created successfully".to_string())))
                        }
                    )*
                }
            }

            /// Updates an existing entity by ID
            #vis fn update_entity(&mut self, id: &str, entity: Entity) -> ::std::result::Result<(::stately::EntityIdentifier, Option<String>), String> {
                use ::stately::StateCollection;
                // Parse the ID to Uuid
                let entity_id: ::stately::EntityIdentifier = id.parse()
                    .map_err(|_| format!("Invalid UUID: {}", id))?;

                match entity {
                    #(
                        Entity::#singleton_variants(inner) => {
                            self.#singleton_fields.update(id, inner)
                                .map_err(|e| format!("Failed to update entity: {}", e))?;
                            Ok((entity_id, Some("Entity updated successfully".to_string())))
                        }
                    )*
                    #(
                        Entity::#collection_variants(inner) => {
                            self.#collection_fields.update(id, inner)
                                .map_err(|e| format!("Failed to update entity: {}", e))?;
                            Ok((entity_id, Some("Entity updated successfully".to_string())))
                        }
                    )*
                }
            }

            /// Removes an entity by ID and type
            #vis fn remove_entity(&mut self, id: &str, entry: StateEntry) -> ::std::result::Result<Option<String>, String> {
                use ::stately::StateCollection;
                match entry {
                    #(
                        StateEntry::#singleton_variants => {
                            self.#singleton_fields.remove(id)?;
                            Ok(Some("Entity removed successfully".to_string()))
                        }
                    )*
                    #(
                        StateEntry::#collection_variants => {
                            self.#collection_fields.remove(id)?;
                            Ok(Some("Entity removed successfully".to_string()))
                        }
                    )*
                }
            }

            /// Gets an entity by ID and type
            #vis fn get_entity(&self, id: &str, entry: StateEntry) -> Option<(::stately::EntityIdentifier, Entity)> {
                use ::stately::StateCollection;
                match entry {
                    #(
                        StateEntry::#singleton_variants => {
                            self.#singleton_fields.get_entity(id).map(|(id, e)| (*id, Entity::#singleton_variants(e.clone())))
                        }
                    )*
                    #(
                        StateEntry::#collection_variants => {
                            self.#collection_fields.get_entity(id).map(|(id, e)| (*id, Entity::#collection_variants(e.clone())))
                        }
                    )*
                }
            }

            /// Lists all entities of a specific type
            #vis fn list_entities(&self, entry: Option<StateEntry>) -> ::stately::hashbrown::HashMap<StateEntry, Vec<::stately::Summary>> {
                use ::stately::StateCollection;
                let mut result = ::stately::hashbrown::HashMap::default();

                #(
                    if entry.is_none() || entry == Some(StateEntry::#singleton_variants) {
                        result.insert(StateEntry::#singleton_variants, self.#singleton_fields.list());
                    }
                )*
                #(
                    if entry.is_none() || entry == Some(StateEntry::#collection_variants) {
                        result.insert(StateEntry::#collection_variants, self.#collection_fields.list());
                    }
                )*

                result
            }

            /// Searches entities across all collections
            #vis fn search_entities(&self, needle: &str) -> ::stately::hashbrown::HashMap<StateEntry, ::stately::hashbrown::HashMap<::stately::EntityIdentifier, Entity>> {
                use ::stately::StateCollection;
                let mut result = ::stately::hashbrown::HashMap::default();

                #(
                    {
                        let matches = self.#singleton_fields.search_entities(needle);
                        if !matches.is_empty() {
                            let mut entities = ::stately::hashbrown::HashMap::default();
                            for (id, entity) in matches {
                                entities.insert(*id, Entity::#singleton_variants(entity.clone()));
                            }
                            result.insert(StateEntry::#singleton_variants, entities);
                        }
                    }
                )*
                #(
                    {
                        let matches = self.#collection_fields.search_entities(needle);
                        if !matches.is_empty() {
                            let mut entities = ::stately::hashbrown::HashMap::default();
                            for (id, entity) in matches {
                                entities.insert(*id, Entity::#collection_variants(entity.clone()));
                            }
                            result.insert(StateEntry::#collection_variants, entities);
                        }
                    }
                )*

                result
            }
        }

        // Generate StatelyState trait implementation for axum feature
        #[cfg(feature = "axum")]
        impl ::stately::StatelyState for #name {
            type StateEntry = StateEntry;
            type Entity = Entity;

            fn create_entity(&mut self, entity: Self::Entity) -> ::std::result::Result<(::stately::EntityIdentifier, Option<String>), String> {
                self.create_entity(entity)
            }

            fn update_entity(&mut self, id: &str, entity: Self::Entity) -> ::std::result::Result<(::stately::EntityIdentifier, Option<String>), String> {
                self.update_entity(id, entity)
            }

            fn remove_entity(&mut self, id: &str, entry: Self::StateEntry) -> ::std::result::Result<Option<String>, String> {
                self.remove_entity(id, entry)
            }

            fn get_entity(&self, id: &str, entry: Self::StateEntry) -> Option<(::stately::EntityIdentifier, Self::Entity)> {
                self.get_entity(id, entry)
            }

            fn list_entities(&self, entry: Option<Self::StateEntry>) -> ::stately::hashbrown::HashMap<Self::StateEntry, Vec<::stately::Summary>> {
                self.list_entities(entry)
            }

            fn search_entities(&self, needle: &str) -> ::stately::hashbrown::HashMap<Self::StateEntry, ::stately::hashbrown::HashMap<::stately::EntityIdentifier, Self::Entity>> {
                self.search_entities(needle)
            }
        }
    };

    // Note: API generation is now handled by the #[axum_api] macro
    // Users should explicitly use #[axum_api(StateName)] on their API state struct

    // Generate Stately{Name} wrapper struct for axum integration
    let stately_name = syn::Ident::new(&format!("Stately{}", name), name.span());

    let stately_struct = quote! {
        /// Wrapper around state for Axum integration with Arc<RwLock<T>>
        #[derive(Clone)]
        #vis struct #stately_name {
            #vis state: ::std::sync::Arc<::stately::tokio::sync::RwLock<#name>>,
        }

        impl #stately_name {
            /// Creates a new wrapped state for use with Axum
            #vis fn new(state: #name) -> Self {
                Self {
                    state: ::std::sync::Arc::new(::stately::tokio::sync::RwLock::new(state)),
                }
            }
        }
    };

    let expanded = quote! {
        #core_code
        #stately_struct
    };

    TokenStream::from(expanded)
}

/// Extracts the type identifier from a type
fn extract_type_ident(ty: &syn::Type) -> syn::Ident {
    match ty {
        syn::Type::Path(type_path) => {
            // Get the last segment of the path
            type_path.path.segments.last().unwrap().ident.clone()
        }
        _ => panic!("Unsupported type for state field"),
    }
}
